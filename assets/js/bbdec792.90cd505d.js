"use strict";(self.webpackChunkengineering_playbook=self.webpackChunkengineering_playbook||[]).push([[6721],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),u=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(n),h=a,m=c["".concat(s,".").concat(h)]||c[h]||p[h]||i;return n?o.createElement(m,r(r({ref:t},d),{},{components:n})):o.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var u=2;u<i;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1230:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var o=n(7462),a=(n(7294),n(3905));const i={},r="Intro to CI/CD",l={unversionedId:"developing/cicd/intro",id:"developing/cicd/intro",title:"Intro to CI/CD",description:"The goal of CI/CD practice is to provide a workflow that can support",source:"@site/docs/developing/cicd/intro.md",sourceDirName:"developing/cicd",slug:"/developing/cicd/intro",permalink:"/docs/developing/cicd/intro",draft:!1,editUrl:"https://github.com/trussworks/Engineering-Playbook/edit/main/docs/developing/cicd/intro.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dependabot",permalink:"/docs/developing/cicd/dependabot"},next:{title:"Code Reviews",permalink:"/docs/developing/code-reviews/"}},s={},u=[{value:"Delivery Pipeline Basics",id:"delivery-pipeline-basics",level:2},{value:"Build",id:"build",level:3},{value:"Notes about Versioning",id:"notes-about-versioning",level:4},{value:"Semantic Versioning",id:"semantic-versioning",level:5},{value:"Commit Hash",id:"commit-hash",level:5},{value:"Other versioning strategies",id:"other-versioning-strategies",level:5},{value:"Test",id:"test",level:3},{value:"Deployment",id:"deployment",level:3},{value:"Release",id:"release",level:3},{value:"Continuous (Integration | Delivery | Deployment)",id:"continuous-integration--delivery--deployment",level:2},{value:"Continuous Integration",id:"continuous-integration",level:3},{value:"Continuous Delivery",id:"continuous-delivery",level:3},{value:"Continuous Deployment",id:"continuous-deployment",level:3}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"intro-to-cicd"},"Intro to CI/CD"),(0,a.kt)("p",null,"The goal of CI/CD practice is to provide a workflow that can support\nfrequent updates, good testing, consistent builds, and prompt deploys.\nAdditionally issues with code should be found quickly and addressed before\nit is released to customers."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#delivery-pipeline-basics"},"Delivery Pipeline Basics"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#build"},"Build"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#notes-about-versioning"},"Notes about Versioning"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#semantic-versioning"},"Semantic Versioning")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#commit-hash"},"Commit Hash")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#other-versioning-strategies"},"Other versioning strategies")))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#test"},"Test")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#deployment"},"Deployment")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#release"},"Release")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#continuous-integration--delivery--deployment"},"Continuous (Integration | Delivery | Deployment)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#continuous-integration"},"Continuous Integration")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#continuous-delivery"},"Continuous Delivery")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#continuous-deployment"},"Continuous Deployment"))))),(0,a.kt)("h2",{id:"delivery-pipeline-basics"},"Delivery Pipeline Basics"),(0,a.kt)("p",null,"There are usually four conceptual steps in a delivery pipeline:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Build"),": Where you build the code into a binary or other artifacts to eventually distribute."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Test"),": Where you validate or test the artifacts built in the previous step."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Deploy"),": Where you configure and deploy the artifacts to an environment. Could be a pre-prod or prod."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Release"),": Where you finally allow users access to that version of code you've configured and built.")),(0,a.kt)("p",null,"In many cases you can merge or swap the steps ",(0,a.kt)("inlineCode",{parentName:"p"},"Release")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Deploy"),"."),(0,a.kt)("p",null,"Philosophical ideas and notes about each step are outlined in the following sections.\nThese are not the be-all end-all of what we do at Truss but are a starting point for how we think about this process."),(0,a.kt)("p",null,"Note: These steps are all fungible.\nThey can be combined to a degree, you can have multiple deployment and validation steps.\nYou could merge deploy and release.\nWhat is important is that each of those steps is well understood and documented.\nThat they are configurable and repeatable."),(0,a.kt)("h3",{id:"build"},"Build"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Builds should be repeatable."),"\nThis means you should be able to check out the code from your project at that same commit hash and build it again and get the same artifact(s).\n",(0,a.kt)("em",{parentName:"p"},"Note"),": This means that dependencies should be versioned in your codebase.\nTo keep dependencies up to date in an automated way you can use ",(0,a.kt)("a",{parentName:"p",href:"https://dependabot.com/"},"Dependabot")," with our ",(0,a.kt)("a",{parentName:"p",href:"/docs/developing/cicd/dependabot"},"documentation on configuring it"),'.\nPlease do whatever is "correct" in the context of the languages/frameworks your project is built in.'),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Builds should be hermetic.")," This means that the build should be isolated from other builds.\nIn CI, the build shouldn't share the same workspace or files from a previous build or from a build of a different project."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Builds should output an immutable artifact.")," Artifact outputs should not be rewritten or altered by subsequent builds.\nThis allows you to distribute or redeploy from these unaltered artifacts for different points in code.\nAdditionally, try to label the artifact with the appropriate versioning scheme for your project."),(0,a.kt)("h4",{id:"notes-about-versioning"},"Notes about Versioning"),(0,a.kt)("p",null,"Version your code and artifacts. Doesn't really matter how, just do it. It will make it easier to track down issues or deploy specific versions of your project."),(0,a.kt)("p",null,"In your code consider adding a command or an endpoint that surfaces that version for debugging."),(0,a.kt)("p",null,"Tag your versioned releases on your mainline branch.\nThis helps you find the state of mainline at the point in time your artifact was built.\nAdditionally, if you are using GitHub you can use their releases functionality to share release artifacts and notes."),(0,a.kt)("p",null,"Here is a preferential ordering of versioning schemes:"),(0,a.kt)("h5",{id:"semantic-versioning"},"Semantic Versioning"),(0,a.kt)("p",null,"Why semver? It tells you and your customer how much has changed since the last released code and sets expectations accordingly.\nIf you are tagging at mainline where you are building from, you can rebuild the artifact from the same point."),(0,a.kt)("p",null,"From ",(0,a.kt)("a",{parentName:"p",href:"https://semver.org"},"semver.org"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Given a version number MAJOR.MINOR.PATCH, increment the:\n\nMAJOR version when you make incompatible API changes,\nMINOR version when you add functionality in a backwards compatible manner, and\nPATCH version when you make backwards compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n")),(0,a.kt)("h5",{id:"commit-hash"},"Commit Hash"),(0,a.kt)("p",null,"A commit hash is unique (with extremely few collisions) and is easily linked back to history in code.\nHowever, how much has changed is opaque to your users and it is difficult to determine how old this version is in comparison to other versions."),(0,a.kt)("h5",{id:"other-versioning-strategies"},"Other versioning strategies"),(0,a.kt)("p",null,"These are other versioning strategies we've seen. We do not recommend them."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Feature branch related names.")," These should be short lived and maintained for no more than a few days. Most users will not find these useful."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Build id related names.")," These are opaque to a user and harder to dig up history on when debugging."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Build date related names.")," These are also opaque to a user and difficult to dig up history on when debugging. You at least get a sense of when these changes went in but are hard to tie to a commit in mainline.")),(0,a.kt)("h3",{id:"test"},"Test"),(0,a.kt)("p",null,"We will not be writing deeply about testing methodologies or specifics around kinds of tests and the philosophies here."),(0,a.kt)("p",null,"In the context of a CI pipeline:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tests should be hermetic.")," Ideally, multiple CI runs should be able to run at the same time without affecting each other."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tests should be idempotent.")," Tests in CI should be able to run several times over without producing inconsistent effects."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tests should be reproducible in a developer's computer.")," So developers can debug them more easily."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tests should run fast."),' "Fast" is poorly defined here.\nGenerally speaking, you want tests to be fast so merging code changes is fast.\nA developer shouldn\'t think they can start on a new piece of work in the hour or two to push a change through CI and context switch.'),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tests should fail fast."),' Similar to the previous point, "fast" is relative but in CI you will want to give the waiting devloper signal on whether their work can be merged or requires changes as quick as possible.'),(0,a.kt)("h3",{id:"deployment"},"Deployment"),(0,a.kt)("p",null,"Deployment will differ project to project and should take into account the requirements of the system being deployed to."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Deployment should be repeatable.")," The same code and configuration should be deployable again and again."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Deployment process for software should be the same regardless of environment.")," Using the same process and tooling means lower cognitive overhead in deployment and your non production environments should reflect production more closely."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Deployment tools should be maintained separate from the application being deployed.")," We've seen this happen where we need to fix some deployed code but also had a problem with the code that performs the deployment and all of it is a hairy mess of debugging."),(0,a.kt)("h3",{id:"release"},"Release"),(0,a.kt)("p",null,"There are a few different ways of implementing release.\nNo matter what, release is the step when you allow customers to have access to that particular version of your code."),(0,a.kt)("p",null,"If you're releasing a CLI, it may mean that you're releasing your binary to a Homebrew tap or just a zip file to GitHub releases."),(0,a.kt)("p",null,"If you have a service, you could have a loadbalancer manage traffic between different versions of your services.\nOr you could use something like Launch Darkly to leverage feature flags to do something similar for different user cohorts."),(0,a.kt)("h2",{id:"continuous-integration--delivery--deployment"},"Continuous (Integration | Delivery | Deployment)"),(0,a.kt)("p",null,"We throw around terms like CI or CD with the assumption that we know what the differences are between these practices."),(0,a.kt)("p",null,"For clarity, at Truss we'll refer to them as follows:"),(0,a.kt)("h3",{id:"continuous-integration"},"Continuous Integration"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Continuous Integration")," is when you validate on every push to mainline.\nThis helps folks find failures in the code before it reaches mainline.\nIdeally, automated build and test steps validate changes and stop any new changes to mainline.\nMainline must always be in a good state to deploy from."),(0,a.kt)("p",null,"This may manifest as a process where developers merge changes into mainline as often as possible.\nSmall incremental changes to code and small discrete tests make changes easier to understand and facilitate frequent merges in CI.\nThis practice helps mitigate risks from long lived branches and helps validate small changes in quick succession."),(0,a.kt)("p",null,"That being said, in practice we see longer lived branches for features or versions.\nThese branches need to be kept up to date with mainline with frequent merges or rebases from mainline."),(0,a.kt)("p",null,"The point of either of those practices is to minimize drift between your working branch and mainline so validation in CI or manually is easier."),(0,a.kt)("h3",{id:"continuous-delivery"},"Continuous Delivery"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Continuous Delivery")," can be described as an extension to ",(0,a.kt)("inlineCode",{parentName:"p"},"Continuous Integration"),".\nIn addition to automated build and test steps running on every proposed change to mainline, the delivery of the code is also automated."),(0,a.kt)("p",null,"You want the software built to be deployable at any given point in time."),(0,a.kt)("p",null,'Delivery may mean different things depending on your workflow.\nIt may mean that you have built your artifacts and validated them and delivered them to a centralized repository.\nFor example, Docker containers might go to Docker Hub or Amazon Elastic Container Registry (ECR).\nMight mean that the code has been deployed to a staging environment.\nAll of these could be "delivered" depending on the project\'s workflow.'),(0,a.kt)("h3",{id:"continuous-deployment"},"Continuous Deployment"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Continuous Deployment")," can be described as a further extension of ",(0,a.kt)("inlineCode",{parentName:"p"},"Continuous Delivery"),".\nIn addition to automated build, test, and delivery, production deployment is also automated."),(0,a.kt)("p",null,"This is an advanced state that requires excellent, trustworthy, automated tests and monitoring. The complexity of continuous deployment system is correlated with the complexity of the delivery pipeline. It's much easier to have continous deployment of a single container image than a full-featured web application."))}p.isMDXComponent=!0}}]);