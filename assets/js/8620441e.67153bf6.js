"use strict";(self.webpackChunkengineering_playbook=self.webpackChunkengineering_playbook||[]).push([[8951],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>d});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=s(t),d=a,g=m["".concat(p,".").concat(d)]||m[d]||u[d]||o;return t?r.createElement(g,i(i({ref:n},l),{},{components:t})):r.createElement(g,i({ref:n},l))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var s=2;s<o;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1532:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var r=t(7462),a=(t(7294),t(3905));const o={},i="CircleCI Config Patterns",c={unversionedId:"developing/cicd/circleci-patterns",id:"developing/cicd/circleci-patterns",title:"CircleCI Config Patterns",description:"At Truss, CircleCI tends to be our CI/CD tool of choice. In order to help",source:"@site/docs/developing/cicd/circleci-patterns.md",sourceDirName:"developing/cicd",slug:"/developing/cicd/circleci-patterns",permalink:"/docs/developing/cicd/circleci-patterns",draft:!1,editUrl:"https://github.com/trussworks/Engineering-Playbook/edit/main/docs/developing/cicd/circleci-patterns.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CircleCI Orbs",permalink:"/docs/developing/cicd/circleci-orbs"},next:{title:"CircleCI Utilities",permalink:"/docs/developing/cicd/circleci-utilities"}},p={},s=[{value:"Split Build/Push Steps",id:"split-buildpush-steps",level:2},{value:"Multiple Account Operations",id:"multiple-account-operations",level:2},{value:"Manual Approval by Restricted Groups",id:"manual-approval-by-restricted-groups",level:2}],l={toc:s};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"circleci-config-patterns"},"CircleCI Config Patterns"),(0,a.kt)("p",null,"At Truss, CircleCI tends to be our CI/CD tool of choice. In order to help\ndevelopers and infrastructure engineers get their pipelines working quickly,\nthere are some patterns you can use to make your pipeline more robust."),(0,a.kt)("h2",{id:"split-buildpush-steps"},"Split Build/Push Steps"),(0,a.kt)("p",null,"If you are building a pipeline that builds docker images and then deploys\nthem to multiple repositories, you can save the built image to the CircleCI\nworkspace, then load it via another. You will have two commands, a build\ncommand and a push command, and you'll run the build job once, and a push\njob for each repository."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Build/Push Config Pattern"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"commands:\n  build_image:\n    parameters:\n      dockerfile:\n        type: string\n      image_name:\n        type: string\n      tag:\n        type: string\n    steps:\n      - run:\n          name: 'Build docker image'\n          command: |\n            docker build -f << parameters.dockerfile >> -t << parameters.image_name >>:<< parameters.tag >> .\n            mkdir -p workspace\n            docker save -o workspace/<< parameters.image_name >> << parameters.image_name >>:<< parameters.tag >>\n      - persist_to_workspace:\n          root: workspace\n          paths:\n            - << parameters.image_name >>\n\n  push_image:\n    parameters:\n      image_name:\n        type: string\n      tag:\n        type: string\n      repo:\n        type: string\n    steps:\n      - attach_workspace:\n          at: /tmp/workspace\n      - run:\n          name: 'Retrieve docker image from workspace'\n          command: |\n            docker load -i /tmp/workspace/<< parameters.image_name >>\n      - run:\n          name: 'Tag and push docker image'\n          command: |\n            bash -c \"$(aws ecr get-login --no-include-email --region $AWS_REGION)\"\n            docker tag << parameters.image_name >>:<< parameters.tag >> ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/<< parameters.repo >>:git-commit-${CIRCLE_SHA1}\n            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/<< parameters.repo >>:git-commit-${CIRCLE_SHA1}\n\njobs:\n  build:\n    executor: main\n    steps:\n      - checkout\n      - setup_remote_docker:\n          # You can set docker_layer_caching to true if you have a paid plan\n          docker_layer_caching: false\n      - make bin_linux/my_app\n      - build_image:\n          dockerfile: Dockerfile\n          image_name: my_app\n          tag: latest\n\n  push:\n    executor: main\n    steps:\n      - setup_remote_docker:\n          # You can set docker_layer_caching to true if you have a paid plan\n          docker_layer_caching: false\n      - push_image:\n          image_name: my_app\n          tag: latest\n          repo: app-my_app\n"))),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://support.circleci.com/hc/en-us/articles/360019182513-Build-Docker-image-in-one-job-and-use-in-another-job"},"Build Docker image in one job and use in another job")),(0,a.kt)("h2",{id:"multiple-account-operations"},"Multiple Account Operations"),(0,a.kt)("p",null,"With the use of AWS Organizations, it's not uncommon that we want CircleCI\nto execute steps in different AWS accounts. You can update AWS credentials\nand variables by saving multiple versions of the environment variables in\nCircleCI, and then using commands to swap between them. See the example\ncode below:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Multiple AWS Account Credentials Pattern"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'  commands:\n    aws_vars_dev:\n      steps:\n        - run:\n            name: \'Setting up AWS environment variables for dev\'\n            command: |\n              echo "export AWS_REGION=$DEV_REGION" >> $BASH_ENV\n              echo "export AWS_ACCOUNT_ID=$DEV_ACCOUNT_ID" >> $BASH_ENV\n              echo "export AWS_ACCESS_KEY_ID=$DEV_ACCESS_KEY" >> $BASH_ENV\n              echo "export AWS_SECRET_ACCESS_KEY=$DEV_SECRET_ACCESS_KEY" >> $BASH_ENV\n\n    aws_vars_prod:\n      steps:\n        - run:\n            name: \'Setting up AWS environment variables for prod\'\n            command: |\n              echo "export AWS_REGION=$PROD_REGION" >> $BASH_ENV\n              echo "export AWS_ACCOUNT_ID=$PROD_ACCOUNT_ID" >> $BASH_ENV\n              echo "export AWS_ACCESS_KEY_ID=$PROD_ACCESS_KEY" >> $BASH_ENV\n              echo "export AWS_SECRET_ACCESS_KEY=$PROD_SECRET_ACCESS_KEY" >> $BASH_ENV\n\n  jobs:\n    do_thing_dev:\n      executor: main\n      steps:\n        - aws_vars_dev\n        - do_thing:\n            environment: dev\n\n    do_thing_prod:\n      executor: main\n      steps:\n        - aws_vars_prod\n        - do_thing:\n            environment: prod\n'))),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://circleci.com/docs/2.0/env-vars/#using-bash_env-to-set-environment-variables"},"Using ",(0,a.kt)("inlineCode",{parentName:"a"},"BASH_ENV")," to set environment variables")),(0,a.kt)("h2",{id:"manual-approval-by-restricted-groups"},"Manual Approval by Restricted Groups"),(0,a.kt)("p",null,"If you need to gate part of your CI/CD pipeline to a small group (for\nexample, you want only product managers to be able to approve deploys to\nyour production environment), you can use a CircleCI restricted context\nto achieve this. You will need to create a GitHub team for the people you\nwant to be able to approve these jobs, create a context in the CircleCI\nUI that includes this team only, and then add the context to all jobs\n",(0,a.kt)("em",{parentName:"p"},"after")," the approval job."),(0,a.kt)("p",null,"Reference: ",(0,a.kt)("a",{parentName:"p",href:"https://circleci.com/docs/2.0/contexts/"},"CircleCI Contexts")))}u.isMDXComponent=!0}}]);