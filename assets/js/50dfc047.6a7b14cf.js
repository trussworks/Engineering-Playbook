"use strict";(self.webpackChunkengineering_playbook=self.webpackChunkengineering_playbook||[]).push([[8795],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(a),d=i,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||r;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7845:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={},l="Naming",o={unversionedId:"infrasec/aws/naming",id:"infrasec/aws/naming",title:"Naming",description:"Naming is one of the hard problems in computing. Naming instances in a shared name space, such as AWS, is especially rife with problems. Often a company uses a single AWS account across multiple projects and so the projects have to negotiate how to share the namespace for resources. There are a number of different axes of belonging we might want to include in the name: to which project does a resource belong, to which environment (dev, prod, staging), which function within the environment. Then there are entities which exist only in terms of their relationship to other objects, e.g. roles associated with a particular lambda function.",source:"@site/docs/infrasec/aws/naming.md",sourceDirName:"infrasec/aws",slug:"/infrasec/aws/naming",permalink:"/docs/infrasec/aws/naming",draft:!1,editUrl:"https://github.com/trussworks/Engineering-Playbook/edit/main/docs/infrasec/aws/naming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GuardDuty for Organizations",permalink:"/docs/infrasec/aws/guardduty"},next:{title:"Bootstrapping an AWS Organization",permalink:"/docs/infrasec/aws/org-bootstrap"}},s={},p=[{value:"Globally unique",id:"globally-unique",level:2},{value:"S3 Buckets",id:"s3-buckets",level:3},{value:"Unique per account",id:"unique-per-account",level:2},{value:"IAM resources",id:"iam-resources",level:3},{value:"IAM policies",id:"iam-policies",level:4},{value:"IAM users",id:"iam-users",level:4},{value:"Unique per region",id:"unique-per-region",level:2},{value:"SNS topics",id:"sns-topics",level:3},{value:"Slackbot",id:"slackbot",level:3},{value:"VPC",id:"vpc",level:3},{value:"Subnets",id:"subnets",level:3},{value:"ECR",id:"ecr",level:3},{value:"Container images",id:"container-images",level:3},{value:"Terraform modules",id:"terraform-modules",level:2}],u={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"naming"},"Naming"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Naming")," is one of the ",(0,i.kt)("a",{parentName:"p",href:"https://martinfowler.com/bliki/TwoHardThings.html"},"hard problems in computing"),". Naming instances in a shared name space, such as AWS, is especially rife with problems. Often a company uses a single AWS account across multiple projects and so the projects have to negotiate how to share the namespace for resources. There are a number of different axes of belonging we might want to include in the name: to which project does a resource belong, to which environment (dev, prod, staging), which function within the environment. Then there are entities which exist only in terms of their relationship to other objects, e.g. roles associated with a particular lambda function."),(0,i.kt)("p",null,"Things are further complicated in AWS because there are different uniqueness constraints in play:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Uniqueness constraint"),(0,i.kt)("th",{parentName:"tr",align:null},"Example resources"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Global (the entirety of AWS)"),(0,i.kt)("td",{parentName:"tr",align:null},"S3 buckets")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Per account"),(0,i.kt)("td",{parentName:"tr",align:null},"IAM resources (users, groups, roles, policies, \u2026)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Per region"),(0,i.kt)("td",{parentName:"tr",align:null},"Most everything else (ALB, ECS, RDS, \u2026)")))),(0,i.kt)("p",null,"As with all naming schemes (and other stylistic things such as casing and comments) where the client already has a functional naming scheme we should follow that - there are more important issues to deal with. However, for our own work and for projects where we are setting the standard tend to use the following."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#globally-unique"},"Globally unique"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#s3-buckets"},"S3 Buckets")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#unique-per-account"},"Unique per account"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#iam-resources"},"IAM resources"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#iam-policies"},"IAM policies")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#iam-users"},"IAM users")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#unique-per-region"},"Unique per region"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#sns-topics"},"SNS topics")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#slackbot"},"Slackbot")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#vpc"},"VPC")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#subnets"},"Subnets")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ecr"},"ECR")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#container-images"},"Container images")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#terraform-modules"},"Terraform modules"))),(0,i.kt)("h2",{id:"globally-unique"},"Globally unique"),(0,i.kt)("h3",{id:"s3-buckets"},"S3 Buckets"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${account.alias}-${application.name}[-${environment}][-${region}]")," - these names begin with a consistent account/usage prefix as they are globally scoped across all of AWS."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$account-alias"),' - is a prefix for the account, e.g. "truss", "client-name"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$application-name"),' - is application for which the resource is created, e.g. "aws-logs", "webserver", "terraform-state"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$environment")," - can be used to distinguish different versions of the resource/app that occur during the development lifecycle, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"dev"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"perf_test"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"staging")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"prod"),"uction"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$region")," - when an app can or will be distributed across AWS regions with distinct instances in each region, this postfix distinguishes between them")),(0,i.kt)("p",null,"e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"truss-aws-logs-us-east-1")),(0,i.kt)("h2",{id:"unique-per-account"},"Unique per account"),(0,i.kt)("h3",{id:"iam-resources"},"IAM resources"),(0,i.kt)("p",null,"IAM resource names are account unique (i.e., visible across all regions), e.g. for roles:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${service/realm}[-${role}]-${project/application}-${environment}")," - is the general form"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$service/realm"),' - to what does this role pertain, e.g. "ecs", "lamda" or "circleci".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$role"),' - where there may be multiple roles associated with a service, this can be used as a way of disambiguating, e.g "task-execution" or "rds-snapshot-cleaner"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$project/application"),' - where there may be multiple applications/projects being managed with independent deploy cycles, this is used, e.g. "webapp", "honeycomb"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$environment")," - can be used to distinguish different versions of the resource/app that occur during the development lifecycle, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"dev"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"perf_test"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"staging")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"prod"),"uction")),(0,i.kt)("p",null,"e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"lambda-rds-snapshot-cleaner-app-experimental"),(0,i.kt)("li",{parentName:"ul"},"ecs-task-role-app-client-tls-experimental")),(0,i.kt)("h4",{id:"iam-policies"},"IAM policies"),(0,i.kt)("p",null,"Where the details of an IAM role are in an associated policy (usually the case) they are named after the associated role, but with ",(0,i.kt)("inlineCode",{parentName:"p"},"-policy")," appended, e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"lambda-rds-snapshot-cleaner-app-experimental-policy"),(0,i.kt)("li",{parentName:"ul"},"ecs-task-role-app-client-tls-experimental-policy")),(0,i.kt)("h4",{id:"iam-users"},"IAM users"),(0,i.kt)("p",null,"When you create a new user, you should follow a first initial last name format (firstinitialLastName), e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"eeady for Elizabeth Eady"),(0,i.kt)("li",{parentName:"ul"},"rkilberg for Rebecca Kilberg")),(0,i.kt)("h2",{id:"unique-per-region"},"Unique per region"),(0,i.kt)("p",null,"Where the name is scoped by the resource type and the region, e.g. lambda functions, then it is enough to give a meaningful name and qualify by environment. If the purpose is common, e.g. rds-log-cleaner, it may need an application."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${purpose}[-${application}]-${environment}")," - is the general form"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$purpose"),' - a simple name describing the role/purpose of the resource, e.g. "slack-pivotal-bot", "webserver", "rds-log-cleaner"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$application"),' - if needed, disambiguates between a similar purpose across applications, e.g. "webapp" vs "honeycomb"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$environment")," - can be used to distinguish different versions of the resource/app that occur during the development lifecycle, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"dev"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"perf_test"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"staging")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"prod"),"uction")),(0,i.kt)("p",null,"e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"slack-pivotal-tracker-bot-test"),(0,i.kt)("li",{parentName:"ul"},"rds-log-cleaner-webapp-prod")),(0,i.kt)("h3",{id:"sns-topics"},"SNS topics"),(0,i.kt)("p",null,"The main purpose of the SNS topics are for notifications to teams. The naming convention reflects that, closely followed by the AWS account type (Gov or Com) and action."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${team}-${account_type}-${action}")," - is the general form"),(0,i.kt)("p",null,"Sample names:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"app-com-notification"),(0,i.kt)("li",{parentName:"ul"},"infra-gov-alert")),(0,i.kt)("h3",{id:"slackbot"},"Slackbot"),(0,i.kt)("p",null,"When you are creating a bot in Slack to alert team members to issues, you should include team to alert and app name the alert is coming from."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{team}-${application}"))),(0,i.kt)("p",null,"e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"app-eclkc"),(0,i.kt)("li",{parentName:"ul"},"hosting-ipd")),(0,i.kt)("h3",{id:"vpc"},"VPC"),(0,i.kt)("p",null,"VPCs are unique by region but they should indicate which application and environment level they contain."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"[${application}-]${environment}")," - is the general form"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"$application"),' - if needed, disambiguates between a similar purpose across applications, e.g. "webapp" vs "honeycomb"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"$environment")," - can be used to distinguish different versions of the resource/app that occur during the development lifecycle, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"dev"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"perf_test"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"staging")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"prod"),"uction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"eec-prod")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"staging"))),(0,i.kt)("h3",{id:"subnets"},"Subnets"),(0,i.kt)("p",null,"For non-db subnets: Although they are unique by region, we also want subnets to be descriptively named according to their AZs and public/private status."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${VPC name}-${public/private/db}-${AZ}")," - is the general form"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$public/private/db")," - can be used to distinguish whether the subnet is a private, public, or db subnet"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$AZ")," - Availability Zone (AZ) are within a region and are ordered initials (i.e. ",(0,i.kt)("inlineCode",{parentName:"li"},"us-east-2b"),").")),(0,i.kt)("p",null,'In a VPC named "eec-prod":'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"eec-prod-public-us-east-1a"),(0,i.kt)("li",{parentName:"ul"},"eec-prod-private-us-west-2c")),(0,i.kt)("h3",{id:"ecr"},"ECR"),(0,i.kt)("p",null,"Elastic Container Repositories are unique by region within your account. They should be named according to the united principal of what they will contain. For example, if all the images in the repo will be related to a specific app team, then you can name the repo after the app team. If, on the other hand, they will all be images with variations of a set of software, you could name it after the software."),(0,i.kt)("p",null,"e.g.:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"eclkc"),(0,i.kt)("li",{parentName:"ul"},"php-nginx")),(0,i.kt)("h3",{id:"container-images"},"Container images"),(0,i.kt)("p",null,"Container images such as Docker or ECR images should include the date as a way to version. Although the convention is to name the latest version ",(0,i.kt)("inlineCode",{parentName:"p"},"latest"),", this can become a sticky situation when folks are trying to refresh a build in terraform and they end up not pulling the latest because the name ",(0,i.kt)("inlineCode",{parentName:"p"},"latest")," hasn't changed."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${date}-${application}")," - is the general form\n",(0,i.kt)("inlineCode",{parentName:"p"},"${git commit hash}-${application}")," - for applications that build new images on main and therefore may have multiple images per day"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$date")," - YYYY-MM-DD - disambiguates between other images for the same application"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$git commit hash")," - disambiguates between other images for the same application taken on the same day"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$application"),' - disambiguates between a similar purpose across applications, e.g. "webapp" vs "honeycomb"')),(0,i.kt)("p",null,"e.g. 2020-07-20-eclkc"),(0,i.kt)("h2",{id:"terraform-modules"},"Terraform modules"),(0,i.kt)("p",null,"Typically when building resources and services in terraform, you will follow the naming conventions described above for AWS resources. However, when creating a standalone module, you should use the following convention, which is ",(0,i.kt)("a",{parentName:"p",href:"https://www.terraform.io/docs/registry/modules/publish.html"},"required to add the module to the Terraform registry"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"terraform-${provider}-${purpose}")," - is the general form"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$provider"),' - the terraform provider, e.g. "aws", "pagerduty", "github"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$purpose"),' - a simple name describing the role/purpose of the resource, e.g. "slack-pivotal-bot", "webserver", "rds-log-cleaner"')),(0,i.kt)("p",null,"e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"terraform-aws-rds-log-cleaner"),(0,i.kt)("li",{parentName:"ul"},"terraform-aws-cloudtrail-alarms")))}c.isMDXComponent=!0}}]);