"use strict";(globalThis.webpackChunkengineering_playbook=globalThis.webpackChunkengineering_playbook||[]).push([[3196],{1644:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"web/api/GraphQL-Design-Guide","title":"GraphQL API","description":"This guide was heavily influenced by https://graphql.org/learn/best-practices/","source":"@site/docs/web/api/GraphQL-Design-Guide.md","sourceDirName":"web/api","slug":"/web/api/GraphQL-Design-Guide","permalink":"/docs/web/api/GraphQL-Design-Guide","draft":false,"unlisted":false,"editUrl":"https://github.com/trussworks/Engineering-Playbook/edit/main/docs/web/api/GraphQL-Design-Guide.md","tags":[],"version":"current","frontMatter":{},"sidebar":"about","previous":{"title":"API Guide","permalink":"/docs/web/api/"},"next":{"title":"REST API Design","permalink":"/docs/web/api/rest-api-design/"}}');var r=i(4848),s=i(8453);const t={},o="GraphQL API",h={},l=[{value:"Overview",id:"overview",level:2},{value:"Principles",id:"principles",level:2},{value:"Building GraphQL APIs",id:"building-graphql-apis",level:3},{value:"Schema First",id:"schema-first",level:4},{value:"Versioning and Backwards Compatibility",id:"versioning-and-backwards-compatibility",level:4},{value:"Mutations Communicate Intent",id:"mutations-communicate-intent",level:4},{value:"Errors and Nullability",id:"errors-and-nullability",level:4},{value:"Pagination",id:"pagination",level:4},{value:"Caching",id:"caching",level:4},{value:"Errors",id:"errors",level:4},{value:"Tooling",id:"tooling",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"graphql-api",children:"GraphQL API"})}),"\n",(0,r.jsxs)(n.p,{children:["This guide was heavily influenced by ",(0,r.jsx)(n.a,{href:"https://graphql.org/learn/best-practices/",children:"https://graphql.org/learn/best-practices/"})]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Who is the audience for this guide"}),"\n",(0,r.jsx)(n.li,{children:"Who is the audience for the API"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"principles",children:"Principles"}),"\n",(0,r.jsx)(n.p,{children:"One of the most important things to keep in mind when building a\nGraphQL API is that GraphQL is not REST. In particular, GraphQL is\nmost powerful when used as a way to model your problem domain. This is\nprobably not an exact 1:1 mapping with your database models."}),"\n",(0,r.jsxs)(n.p,{children:["GraphQL is ... a graph. Graphs offer a ",(0,r.jsx)(n.a,{href:"https://graphql.org/learn/thinking-in-graphs/",children:"different way of\nthinking"})," or modeling\nyour data than you may be used to."]}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.a,{href:"https://graphql-rules.com",children:"GraphQL Rules"})," for additional recommendations and best practices"]}),"\n",(0,r.jsx)(n.h3,{id:"building-graphql-apis",children:"Building GraphQL APIs"}),"\n",(0,r.jsx)(n.h4,{id:"schema-first",children:"Schema First"}),"\n",(0,r.jsx)(n.p,{children:"Prefer schema first tooling that allows producers and consumers agree\nupon a data shape prior to implementation. This allows a discussion\nabout the problem domain that is independent of the technology being\nused on either side of the API."}),"\n",(0,r.jsx)(n.p,{children:"By designing your GraphQL schema to fit the way you want to think\nabout the data instead of your implementation, you can evolve your\nimplementation without changing clients."}),"\n",(0,r.jsx)(n.h4,{id:"versioning-and-backwards-compatibility",children:"Versioning and Backwards Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://graphql.org/learn/best-practices/#versioning",children:"Versioning"}),"\nsection of GraphQL Best Practices describes why GraphQL APIs should be\nbackwards compatible and not versioned. ",(0,r.jsx)(n.a,{href:"https://www.apollographql.com/blog/graphql-schema-design-building-evolvable-schemas-1501f3c59ed5/",children:"Building Evolvable\nSchemas"}),"\nhas some concrete advice on how to structure your schema."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://medium.com/@calebmer/when-to-use-graphql-non-null-fields-4059337f6fc8",children:"Nullability also influences schema\nevolution"}),",\nso think carefully about which fields to require."]}),"\n",(0,r.jsx)(n.h4,{id:"mutations-communicate-intent",children:"Mutations Communicate Intent"}),"\n",(0,r.jsxs)(n.p,{children:["GraphQL mutations should be specific enough to communicate the intent\nof the change. Avoid ",(0,r.jsx)(n.a,{href:"https://medium.com/@__xuorig__/graphql-mutation-design-anemic-mutations-dd107ba70496",children:"anemic\nmutations"})]}),"\n",(0,r.jsx)(n.h4,{id:"errors-and-nullability",children:"Errors and Nullability"}),"\n",(0,r.jsxs)(n.p,{children:["GraphQL is designed for returning as much data as possible, even if an\nerror occurs. That can be ",(0,r.jsx)(n.a,{href:"https://medium.com/@calebmer/when-to-use-graphql-non-null-fields-4059337f6fc8",children:"surprising"}),", and surprisingly powerful."]}),"\n",(0,r.jsx)(n.p,{children:"That means both data and errors can be returned."}),"\n",(0,r.jsx)(n.h4,{id:"pagination",children:"Pagination"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://graphql.org/learn/pagination/",children:"Pagination"})," can heavily\ninfluence schema design. The concept of ",(0,r.jsx)(n.a,{href:"https://relay.dev/graphql/connections.htm",children:"GraphQL\nConnections"})," is yet another\nnew and powerful concept to grasp when designing a schema. By\nthinking about this early, you can avoid having to make breaking\nchanges to your schema."]}),"\n",(0,r.jsxs)(n.p,{children:["Simplicity is nice when first starting out and prototyping, but\nit is ",(0,r.jsx)(n.em,{children:"strongly"})," recommended to use the connection concept when using\nthe schema in production."]}),"\n",(0,r.jsx)(n.h4,{id:"caching",children:"Caching"}),"\n",(0,r.jsxs)(n.p,{children:["GraphQL prefers to use GUID for objects to facilitate\n",(0,r.jsx)(n.a,{href:"https://graphql.org/learn/caching/",children:"Caching"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"errors",children:"Errors"}),"\n",(0,r.jsxs)(n.p,{children:["Error handling in GraphQL is ",(0,r.jsx)(n.a,{href:"https://blog.atomist.com/error-handling-in-graphql/",children:"not fully\nstandardized"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Some folks are using ",(0,r.jsx)(n.a,{href:"https://blog.logrocket.com/handling-graphql-errors-like-a-champ-with-unions-and-interfaces/",children:"unions and interfaces to handle\nerrors"}),"\nto encode errors in the response data instead of in the basically\nuntyped ",(0,r.jsx)(n.code,{children:"errors"})," field. This makes the most sense for errors that are\nspecific to the operation being made that you want the client to\nhandle gracefully. It also encourages you to include errors as part of\nyour domain modeling, which is a good thing."]}),"\n",(0,r.jsx)(n.h3,{id:"tooling",children:"Tooling"}),"\n",(0,r.jsxs)(n.p,{children:["Using a schema linter (such as ",(0,r.jsx)(n.a,{href:"https://github.com/cjoudrey/graphql-schema-linter",children:"graphql-schema-linter"}),") and running it as part of your pre-commit checks is recommended. Some of the defaults of such linters may be optimized for large public APIs and should be adjusted to best suit your project."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var a=i(6540);const r={},s=a.createContext(r);function t(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);